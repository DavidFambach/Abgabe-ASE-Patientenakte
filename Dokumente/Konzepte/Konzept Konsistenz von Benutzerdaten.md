# Konzept: Konsistenz von Benutzerdaten
Die maßgebliche Quelle der Benutzerinformationen liegt in der Datenbank des Authentifizierungsdienstes. Darin werden Benutzer über eine eindeutige ID identifiziert. Referenzen auf Benutzer innerhalb des Authentifizierungsdienst werden in der PostgreSQL-Datenbank als Fremdschlüssel markiert. Für diese Fremdschlüssel wird die ON-DELETE-Aktion CASCADE gesetzt [1]. Das führt dazu, dass eine Transaktion, die einen Benutzer löscht, implizit auch alle Datensätze löscht, die auf diesen Benutzer verweisen. Schlägt das Löschen eines abhängigen Datensatzes fehl, wird die Transaktion zurückgerollt, der Benutzer bleibt in der Datenbank bestehen und die Datenbasis bleibt somit konsistent. Ist die Löschung erfolgreich, werden mit der Löschung des Benutzers auch alle abhängigen Datensätze in der Datenbank des Authentifizierungsdienstes gelöscht. Das kaskadierte Löschen aller Datensätze in der Datenbank des Authentifizierungsdienstes, die auf den gelöschten Benutzer verweisen, kann ausgeführt werden, weil die Datenstruktur so aufgebaut ist, dass genau alle Datensätze, die Daten über einen Benutzer halten, per Fremdschlüssel auf diesen Benutzer verweisen. Auf diese Weise werden also genau die Daten, die zu löschen sind gelöscht.
Der Dateiverwaltungsdienst arbeitet auf derselben Benutzerbasis. Die Benutzer in der Dateiverwaltungsdomäne (StorageUser) tragen dieselben IDs wie die entsprechenden Benutzer in der Datenbank des Authentifizierungsdienstes. Zwischen den Benutzern in beiden Domänen besteht eine logische 1-zu-1-Beziehung. Diese Konsistenzbedingung gilt aber nicht strikt. Stattdessen wird nur eine schließliche Konsistenz gefordert: Eine Änderung an der Quelle der Benutzerinformationen, also im Authentifizierungsdienst, wird nicht sofort im Dateiverwaltungsdienst widergespiegelt. Greift eine gültige Sitzung für einen im Dateiverwaltungsdienst nicht angelegten Benutzer auf die Benutzerdaten zu, wird davon ausgegangen, dass der Benutzer neu angelegt wurde und die entsprechende Datenstruktur in der Datenbank des Dateiverwaltungsdienstes erstellt. Das Ereignis, dass in der Datenbank des Authentifizierungsdienstes (Schreibmodell für Benutzerentitäten) ein Benutzer hinzugefügt wurde, wird implizit dadurch an den Dateiverwaltungsdienst übertragen, indem der Authentifizierungsdienst ein gültiges Sitzungstoken für diesen Benutzer ausstellt, das dann am Dateiverwaltungsdienst verwendet wird. Daraufhin wird der Benutzer in der Datenbank des Dateiverwaltungsdienstes (Ein Lesemodell für Benutzerentitäten) angelegt. Nach der Löschung eines Benutzers sind Sitzungen für diesen Benutzer nicht mehr möglich, weswegen derselbe Ansatz bei der Löschung von Benutzern nicht angewendet werden kann. Daher muss das Ereignis, dass in der Datenbank des Authentifizierungsdienstes ein Benutzer gelöscht wurde, muss folglich explizit über eine Event-Queue übertragen werden. Die Datenquelle, also der Authentifizierungsdienst, versendet Nachrichten über Benutzerlöschungen über diese Event-Queue. Alle Dienste, die ein Lesemodell für Benutzerentitäten führen, also im konkreten Fall der Dateiverwaltungsdienst, registrieren sich für diese Nachrichten und holen sie regelmäßig ab. Geht eine Nachricht über einen gelöschten Benutzer ein, wird der entsprechende Benutzer in der Datenbank des Dateiverwaltungsdienstes (StorageUser) gelöscht. Dieser Vorgang löscht erneut über die ON-DELETE-Aktion CASCADE, alle abhängigen Datensätze. Auch die Datenbank des Dateiverwaltungsdienstes ist so aufgebaut, dass das genau die Datensätze sind, die Benutzerdaten enthalten.
Dieses Vorgehen alleine reicht noch nicht, um eine schließliche Konsistenz zu erreichen, weil Nachrichten über eine Benutzerlöschung verloren gehen können. Das ist unter Anderem der Fall, wenn der Authentifizierungsdienst die Datenbanktransaktion für die Löschung des Benutzers erfolgreich abschließt, aber abstürzt, bevor er die Nachricht über die Event-Queue absetzen kann. In diesem Fall wird der Benutzer im Schreibmodell des Authentifizierungsdienstes entfernt, bleibt aber im Lesemodell des Dateiverwaltungsdienstes bestehen. Außerdem können Nachrichten verloren gehen, indem der Dateiverwaltungsdienst das Löschen des Benutzers aufgrund von Fehlern aufgibt. Die entstehende Inkonsistenz wird für die Beispielanwendung hingenommen. Wenn die Anwendung produktiv eingesetzt werden soll und damit Regularien bezüglich der Löschung von Benutzerdaten erfüllen muss, beispielsweise die DSGVO, müsste der Dateiverwaltungsdienst zusätzlich regelmäßige Anfragen an den Authentifizierungsdienst stellen, ob die Benutzer aus der Datenbank des Dateiverwaltungsdienstes noch existieren. Dieser Vorgang kann in Zeiträumen ausgeführt werden, in denen die Anwendung wenig ausgelastet ist, um den Einfluss dieser Maßnahme auf den Betrieb zu reduzieren. Außerdem kann dieser Abgleich gruppenweise erfolgen, das heißt, das nicht immer alle Benutzer überprüft werden, sondern verschiedene Benutzergruppen im Wechsel. Die Gruppierung kann beispielsweise anhand der Restklasse der numerisch aufgefassten Benutzer-ID erfolgen.
Eine weitere Inkonsistenz, die durch das oben beschriebene Vorgehen entstehen kann, tritt durch das fehlerhafte erneute Anlegen eines Benutzers auf. Damit das eintritt, muss eine Anfrage an den Dateiverwaltungsdienst verzögert werden, sodass sie eintrifft, nachdem der Benutzer, zu dem die Sitzung gehört, durch das Ereignis aus der Event-Queue gelöscht wurde. Dadurch wird dieselbe Situation provoziert, die vor dem ersten Anlegen des Benutzers in der Datenbank des Dateiverwaltungsdienstes bestand, sodass der Benutzer erneut angelegt wird. Weil der entsprechende Eintrag zu diesem Zeitpunkt aber nicht mehr in der Datenbank des Authentifizierungsdienstes besteht, wird dieser neu angelegte Benutzer des Dateiverwaltungsdienstes nicht mehr gelöscht. Dieses Problem kann auf dieselbe Weise gelöst werden, wie der Verlust von Nachrichten, wird aber in der Beispielimplementierung hingenommen.
Eine praxistaugliche Implementierung müsste außerdem auch Änderungen in den Benutzerattributen über die Dienste hinweg synchronisieren. Dazu zählen unter anderem Änderungen am Benutzernamen. Die Veränderung des Benutzernamens muss in der Praxis unterstützt werden, weil die Regelungen der DSGVO auch eine Möglichkeit zur Korrektur fordern, die zwar nicht notwendigerweise automatisch ausgeführt werden müssen, aber aus Aufwandsgründen definitiv automatisch abgewickelt werden sollten. Das kann durch einen Ablauf realisiert werden, der dem Vorgehen zur Löschung eines Benutzers ähnelt: Wird ein Benutzerattribut in der Datenbank des Authentifizierungsdienstes geändert, sendet dieser eine entsprechende Nachricht über eine Event-Queue aus, die bei allen Empfängern eine entsprechende Aktualisierung auslöst. Um Inkonsistenzen aus verloren gegangenen Nachrichten zu korrigieren, können die wiederholten Anfragen des Dateiablagedienstes an den Authentifizierungsdienst über den Zustand von Benutzern dahingehend erweitert werden, dass auch Attributänderungen übertragen werden.

[1]: https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK (Zuletzt abgerufen: 24.11.2022 15:30 Uhr)
